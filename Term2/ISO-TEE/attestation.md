From section 3 of *Intel SGX explained*.

## cryptographic primitives

3 aspects:

* confidentiality: attacker cannot obtain the secret from the message in an insecure system
* integrity: receiver is guaranteed to obtain to secret from the message or be noticed that the message was tampered by others
* freshness: receiver is guaranteed to receive the latest message

symmetric key: shared, private key distribution(with confidentiality and integrity, non-trivial!),

asymmetric key: each generates shared & private key, just distribute shared key using a channel guaranteeing integrity, **more complicated and consume more computation resources**

Alice->Bob: Alice uses Bob's public key for encryption, and then Bob uses his private key for decryption

symmetric block ciphers(AES): combined with operation modes such as CTR/CBC/IV

asymmetric algorithms(RSA) can be used to initialize a session based on symmetric encryption: just encrypt the shared key using the receiver's public key

integrity is based on secure hashing functions(SHA) which take unbounded data as input and produce a fixed-size output

integrity based on symmetric algorithms: MAC(Message Authentication Code)

integrity based on asymmetric algorithms(RSA with padding schemes, or ECC, Elliptic Curve Cryptography): signatures, sign using sender's private key, verify using sender's public key

freshness: add a layer of nonce(one-shot random number)/timestamping on the top of a system guaranteeing integrity

## cryptographic constructs

### certificate authorities

assumptions: each party holds correct public keys of other parties

this is an assumption because it is not easy to safely distribute public keys, possible solution: certificate authorities assuming that there is an authority whose public key is safely distributed to all other parties

How can we do with the help of CA: obtain public key of each party, request for a certificate "bind a party's identity to its public key"

essentially, certificate is a digital signature of parties' public keys with their intended usage generated using CA's private key, one can use CA's public key to validate the certificate

### key agreement protocols

exchange shared secret keys only relying on a channel satisfying integrity

example: Diffie-Hellman Key Exchange algorithm(KDE)

However, if Eve can temper the message, he is able to perform a man-in-the-middle attack, which can be mitigated using digital signature.

## Software attestation

chain of trust: verifier trusts PubRK(public manufacturer Root Key), which is used to verify Endorsement Certificate(see certificate authorities); the Endorsement Certificate contains PubAK(public attestation key), the verifier can trust it after verifying the certificate using PubRK and use it to verify attestation signature, which contains *measurement* and *data*, which are the hash of the secure container and the key exchange message generated by the program within the contains respectively 
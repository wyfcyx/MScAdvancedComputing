# 1. Overview

## a glance

secure remote computation?(cloud service, multi-tenant), protect data's confidentiality and integrity, relies on *software attestation*(predecessors: TPM{trusted platform module} and TXT)

what is software attestation: prove to the users that the **specific software** is running in a **secure container** hosted by the **trusted hardware**; container contents are verified through its hash value; user can load any software into the container after the container content is verified by the user

> like digital signature:
>
> 1. Alice generate a pair of (public key, private key)
> 2. Alice wants to send to Bob `m`="Hello world!"
> 3. Alice encrypts the message using the private key into `sign`
> 4. Alice sends `m` and encrypted message `sign` at the same time to Bob
> 5. Bob decrypts `sign` using the public key, if the result equals to `m`, then Bob can **believe that the message `m` is from Alice**

> background knowledge: Diffie-Hellman Key exchange algorithm
>
> 1. Alice and Bob agree on a prime number(17) and a generator(3) of this prime number which satisfies that $g^0,g^1,...,g^{p-1}$ are all different $\mod p$.
> 2. Alice selects a private number 15, calculate $3^{15}\mod 17=6$, and publicly sends it to Bob.
> 3. Bob selects a private number 13, calculates $3^{13}\mod{17}=12$, and publicly send it to Alice.
> 4. Alice and Bob calculate their shared public key: $12^{15}\mod{17}=6^{13}\mod{17}=10$
> 5. Now Alice and Bob can use their shared key for symmetric encryption and they do not need to send the key through the non-secure channel.

details of verification: hardware's manufacturer provides **an endorsement certificate**, the **attestation key** is used to generate a signature against the certificate, 

# 3. security background

From section 3 of *Intel SGX explained*.

## cryptographic primitives

3 aspects:

* confidentiality: attacker cannot obtain the secret from the message in an insecure system
* integrity: receiver is guaranteed to obtain to secret from the message or be noticed that the message was tampered by others
* freshness: receiver is guaranteed to receive the latest message

symmetric key: shared, private key distribution(with confidentiality and integrity, non-trivial!),

asymmetric key: each generates shared & private key, just distribute shared key using a channel guaranteeing integrity, **more complicated and consume more computation resources**

Alice->Bob: Alice uses Bob's public key for encryption, and then Bob uses his private key for decryption

symmetric block ciphers(AES): combined with operation modes such as CTR/CBC/IV

asymmetric algorithms(RSA) can be used to initialize a session based on symmetric encryption: just encrypt the shared key using the receiver's public key

integrity is based on secure hashing functions(SHA) which take unbounded data as input and produce a fixed-size output

integrity based on symmetric algorithms: MAC(Message Authentication Code)

integrity based on asymmetric algorithms(RSA with padding schemes, or ECC, Elliptic Curve Cryptography): signatures, sign using sender's private key, verify using sender's public key

freshness: add a layer of nonce(one-shot random number)/timestamping on the top of a system guaranteeing integrity

## cryptographic constructs

### certificate authorities

assumptions: each party holds correct public keys of other parties

this is an assumption because it is not easy to safely distribute public keys, possible solution: certificate authorities assuming that there is an authority whose public key is safely distributed to all other parties

How can we do with the help of CA: obtain public key of each party, request for a certificate "bind a party's identity to its public key"

essentially, certificate is a digital signature of parties' public keys with their intended usage generated using CA's private key, one can use CA's public key to validate the certificate

### key agreement protocols

exchange shared secret keys only relying on a channel satisfying integrity

example: Diffie-Hellman Key Exchange algorithm(KDE)

However, if Eve can temper the message, he is able to perform a man-in-the-middle attack, which can be mitigated using digital signature.

## Software attestation

chain of trust: verifier trusts PubRK(public manufacturer Root Key), which is used to verify Endorsement Certificate(see certificate authorities); the Endorsement Certificate contains PubAK(public attestation key), the verifier can trust it after verifying the certificate using PubRK and use it to verify attestation signature, which contains *measurement* and *data*, which are the hash of the code/data loaded into secure container and the key exchange message, which is sent to the verifier earlier, generated by the program within the contains respectively

after that, verifier is ensured that the expected software is running in the secure container, and a shared key has been created 

# 5. SGX programming model

PRM is a continuous range of memory whose size is a power of two

EPC is only a part of PRM, each page is of 4KiB, pages can be allocated/freed using SGX instructions,

EPCM: an array where each entry describes an EPC page, in the "trusted memory", may not be a part of PRM? layout of  EPCM entry: {VALID, PT(page type, PT_REG for code/data, or PT_SECS for storing enclave control structures), ENCLAVESECS(exclusively occupied by which enclave, thus enclaves can only share non-EPC untrusted memory)}

SECS: per-enclave metadata, each SECS is stored in an EPC page whose PT is PT_SECS, serves as the beginning and end of the lifecycle of an enclave, content of EPCM entry.ENCLAVESECS, system SW using SECS's va to identify an enclave, these va should be mapped in the page table, enclave code or system SW cannot access SECS, 

enclave memory layout: host process, ELRANGE(enclave linear, specified using SECS.{BASEADDR, SIZE})->EPC pages, outside ELRANGE->non-EPC memory, enclave can access the whole address space whereas host process cannot access ELRANGE

> XCR0 and RFBM(requested feature bitmap)
>
> `XSAVE` instruction can be used to save feature-specific registers when switching contexts, it takes a reference to RFBM as the input which indicates which features is currently used. `XRSTOR` can be used to restore these registers.
>
> when handling system calls, the kernel set the `XCR0` register to the RFBM declared by the application

SECS.ATTRIBUTES: XFRM, SGX guarantees that when code is executing in an enclave, `XCR0` is set to XFRM(extended features request mask)

address translation is still manager by untrusted kernel/hypervisor, but there are some additional checks: each EPC page's EPCM entry has an ADDRESS region. When an address translation results in an EPC page, CPU checks that the given VA must be equal to the ADDRESS in the EPCM entry. EPCM entries also have R/W/X permission control bits.

TCS: per logical processor which runs the enclave code; each TCS is stored in a `PT_TCS` page; enclave code cannot access TCS;

SSA(State Save Area): store enclave's execution content during a HW exception; a part of enclave address space, mapping to EPC `PT_REG` pages which enclave code can access; example enclave address space: ELF header/TCS1/SSA1+SSA2/TCS2/.../code/data;

## 5.6 Enclave measurement

